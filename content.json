{"posts":[{"title":"大锤的第一篇博客","text":"这是我的第一篇博客，基于Hexo搭建的，使用github托管部署，此前我对于markdown语法还不太熟悉，接下来我会发布一些对于我个人而言有帮助的解决问题的经验分享。 通过源码安装 跨域浏览器配置 使用NPM安装 从GitHub下载源代码，并复制到Hexo站点的theme目录或者，使用Git将Icarus仓库克隆到themes目录： Git Bash/Shell1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus -b &lt;version number&gt; --depth 1 可以省略-b &lt;version number&gt;直接获取Icarus主题的最新版本。去掉--depth 1可以下载Icarus主题完整的历史提交记录。此外，可以使用以下命令将Icarus安装为Git子模块： Git Bash/Shell1git submodule add https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 1.在电脑上新建一个目录，例如：C:\\ChromeDev2.在属性=&gt;目标最后加上 --disable-web-security --user-data-dir=C:\\ChromeDev，–user-data-dir的值就是刚才新建的目录。3.点击应用、确定重新打开chrome浏览器。有–disable-web-security，配置成功。 通过NPM安装，在项目根目录运行： Shell1npm install -S hexo-theme-icarus hexo-renderer-inferno 修改项目根目录的_config.yml文件设置主题： _config.yml1theme: icarus 或者使用hexo命令设置主题： Shell1hexo config theme icarus 最后，运行预览！ Shell1hexo server 要了解有关主题、小部件和插件的更多信息，请查看 Icarus 用户指南。您也可以参考此站点的源代码以获取更多示例。它在GitHub中Icarus仓库的site 分支。另外, 您可以在这里找到其他Icarus用户的帮助 GitHub Discussions。 其他资源下面一些资源，可能会使你发现这些资源对进一步自定义站点很有用.您也可以通过以下方式提交Icarus教程 链接地址. Hexo 文档地址 关于ICARUS的更多使用文档 点击这里","link":"/2020/04/01/cl7orgth80003f8u7972u1apm/"}],"tags":[{"name":"开始","slug":"开始","link":"/tags/%E5%BC%80%E5%A7%8B/"},{"name":"Icarus用户指南","slug":"Icarus用户指南","link":"/tags/Icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/"}],"categories":[],"pages":[{"title":"","text":"body, html{ margin: 0; padding: 0; height: 100%; } /* Hide scrollbar for Chrome, Safari and Opera */ body::-webkit-scrollbar { display: none; } /* Hide scrollbar for IE, Edge and Firefox */ body { -ms-overflow-style: none; /* IE and Edge */ scrollbar-width: none; /* Firefox */ } svg { display: block; width: 100%; height: 100vh; position: fixed; top: 0; left: 0; } .scrollElement { position: absolute; height: 6000px; width: 100px; top: 0; z-index: 0; } .btn { position: fixed; bottom: 5%; right: 0px; transform: translateX(-50%); border: 1px solid #fff; border-radius: 5px; font-size: 0.9rem; padding: 0.5rem 0.7em; background-color: transparent; color: #ffffff; font-family: Verdana, Geneva, Tahoma, sans-serif; -webkit-font-smoothing: antialiased; cursor: pointer; transition: all .3s; z-index: 11; } .btn_works { left: 100px; right: unset; text-decoration: none; } .btn:hover { background: #ffffff; color: #1B1734; }","link":"/about/css/animate.css"},{"title":"","text":"body { display: flex; margin: 0; align-items: center; justify-content: center; height: 100vh; /* background-color: white; background-image: url(../assets/images/bg-8.jpg); background-size: cover; background-position: center; background-repeat: no-repeat; */ } body::after { content: \"\"; background-color: white; background-image: url(../assets/images/bg-8.jpg); background-size: cover; background-position: center; background-repeat: no-repeat; opacity: 0.5; top: 0; left: 0; bottom: 0; right: 0; position: absolute; z-index: -1; } canvas { width: 98vmin; height: 98vmin; z-index: 9; }","link":"/about/css/style.css"},{"title":"","text":"console.clear() let moveX = 0 let moveY = 0 let moveFlg = false let clientXStart = 0 let clientYStart = 0 let clientXEnd = 0 let clientYEnd = 0 let rotateSpeed = 0.0001 // Get the canvas element from the DOM const canvas = document.querySelector('#scene') canvas.width = canvas.clientWidth canvas.height = canvas.clientHeight // Store the 2D context const ctx = canvas.getContext('2d') if (window.devicePixelRatio > 1) { canvas.width = canvas.clientWidth * 2 canvas.height = canvas.clientHeight * 2 ctx.scale(2, 2) } ctx.rotate(Math.PI * 2) /* ====================== */ /* ====== VARIABLES ===== */ /* ====================== */ let width = canvas.clientWidth // Width of the canvas let height = canvas.clientHeight // Height of the canvas let rotation = 0 // Rotation of the globe let dots = [] // Every dots in an array /* ====================== */ /* ====== CONSTANTS ===== */ /* ====================== */ /* Some of those constants may change if the user resizes their screen but I still strongly believe they belong to the Constants part of the variables */ const DOTS_AMOUNT = 99 // 点数量 const DOT_RADIUS = 4 // Radius of the dots let GLOBE_RADIUS = width * 0.7 // Radius of the globe let GLOBE_CENTER_Z = -GLOBE_RADIUS // Z value of the globe center let PROJECTION_CENTER_X = width / 2 // X center of the canvas HTML let PROJECTION_CENTER_Y = height / 2 // Y center of the canvas HTML let FIELD_OF_VIEW = width * 0.8 const tags = [ '猫', '梦想化', '诚实', '勤劳', '先知', '我不懂', '搞怪', '文字', '平和', '倔强', '朴素', '身材苗条', '神人', '一风情万种', '少女梦', '财迷', '非主流', '铲屎官', ] const colors = ['#00ff00', '#ffff00', '#3385ff'] class Dot { constructor(x, y, z, tag, color) { this.x = x this.y = y this.z = z this.tag = tag this.color = color this.xProject = 0 this.yProject = 0 this.sizeProjection = 0 } // Do some math to project the 3D position into the 2D canvas project(sin, cos) { const rotX = cos * this.x + sin * (this.z - GLOBE_CENTER_Z) const rotZ = -sin * this.x + cos * (this.z - GLOBE_CENTER_Z) + GLOBE_CENTER_Z this.sizeProjection = FIELD_OF_VIEW / (FIELD_OF_VIEW - rotZ) this.xProject = rotX * this.sizeProjection + PROJECTION_CENTER_X this.yProject = this.y * this.sizeProjection + PROJECTION_CENTER_Y } // 绘制点 draw(sin, cos) { this.project(sin, cos) // ctx.fillRect( // this.xProject - DOT_RADIUS, // this.yProject - DOT_RADIUS, // DOT_RADIUS * 2 * this.sizeProjection, // DOT_RADIUS * 2 * this.sizeProjection // ) // ctx.fillStyle = 'yellow' // ctx.fillRect( // this.xProject - DOT_RADIUS, // this.yProject - 4 * DOT_RADIUS, // DOT_RADIUS * 2, // DOT_RADIUS * 2 // ) ctx.fillStyle = '#f2f2f2' ctx.font = `${20 * this.sizeProjection}px Arial` // var txt = 'Hello World' var txt = this.tag ctx.fillText( txt, this.xProject - ctx.measureText(txt).width / 2, this.yProject - 4 * DOT_RADIUS ) ctx.beginPath() ctx.arc( this.xProject, this.yProject, DOT_RADIUS * this.sizeProjection, 0, Math.PI * 2 ) ctx.closePath() ctx.fillStyle = this.color // ctx.fillStyle = '#ccccff' // ctx.closePath()//闭合轨迹 会把线连接到某一点形成闭合轨迹 ctx.fill() } } /** * 创建点集合 */ function createDots() { // Empty the array of dots dots.length = 0 // Create a new dot based on the amount needed // for (let i = 0; i < DOTS_AMOUNT; i++) { // const theta = Math.random() * 2 * Math.PI // Random value between [0, 2PI] // const phi = Math.acos(Math.random() * 2 - 1) // Random value between [-1, 1] // // Calculate the [x, y, z] coordinates of the dot along the globe // const x = GLOBE_RADIUS * Math.sin(phi) * Math.cos(theta) // const y = GLOBE_RADIUS * Math.sin(phi) * Math.sin(theta) // const z = GLOBE_RADIUS * Math.cos(phi) + GLOBE_CENTER_Z // dots.push(new Dot(x, y, z)) // } const arr1 = [] let val1 = 0 for (let i = 0; i < DOTS_AMOUNT; i++) { val1 += 0.99 / DOTS_AMOUNT arr1.push(val1) } // const arr2 = [] // let val2 = 0.5 // for (let i = 0; i < DOTS_AMOUNT; i++) { // val2 += 0.99 / DOTS_AMOUNT // arr2.push(val2) // } for (let i = 0; i < DOTS_AMOUNT; i++) { // 生成的点坐标 const val = Math.random() // const val = arr1[DOTS_AMOUNT - i] const theta = val * 2 * Math.PI // Random value between [0, 2PI] // console.log('随机数', Math.random()) // const phi = Math.acos(Math.random() * 2 - 1) // Random value between [-1, 1] const phi = Math.acos(arr1[i] * 2 - 1) // Random value between [-1, 1] // Calculate the [x, y, z] coordinates of the dot along the globe const x = GLOBE_RADIUS * Math.sin(phi) * Math.cos(theta) const y = GLOBE_RADIUS * Math.sin(phi) * Math.sin(theta) const z = GLOBE_RADIUS * Math.cos(phi) + GLOBE_CENTER_Z dots.push( new Dot(x, y, z, tags[i % tags.length], colors[i % colors.length]) ) } } /* ====================== */ /* ======== RENDER ====== */ /* ====================== */ function render(a) { // Clear the scene ctx.clearRect(0, 0, width, height) // 旋转速度 // Increase the globe rotation rotation = a * rotateSpeed const sineRotation = Math.sin(rotation) // Sine of the rotation const cosineRotation = Math.cos(rotation) // Cosine of the rotation // Loop through the dots array and draw every dot for (var i = 0; i < dots.length; i++) { dots[i].draw(sineRotation, cosineRotation) } window.requestAnimationFrame(render) } // Function called after the user resized its screen function afterResize() { width = canvas.offsetWidth height = canvas.offsetHeight if (window.devicePixelRatio > 1) { canvas.width = canvas.clientWidth * 2 canvas.height = canvas.clientHeight * 2 ctx.scale(2, 2) } else { canvas.width = width canvas.height = height } GLOBE_RADIUS = width * 0.7 GLOBE_CENTER_Z = -GLOBE_RADIUS PROJECTION_CENTER_X = width / 2 PROJECTION_CENTER_Y = height / 2 FIELD_OF_VIEW = width * 0.8 createDots() // Reset all dots } // Variable used to store a timeout when user resized its screen let resizeTimeout // Function called right after user resized its screen function onResize() { // Clear the timeout variable resizeTimeout = window.clearTimeout(resizeTimeout) // Store a new timeout to avoid calling afterResize for every resize event resizeTimeout = window.setTimeout(afterResize, 500) } window.addEventListener('resize', onResize) // 鼠标位置 let mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2, } // Populate the dots array with random dots createDots() // Render the scene window.requestAnimationFrame(render) console.log('对象', ctx) // ctx.canvas.addEventListener( // 'mousedown', // (e) => { // moveFlg = true // moveX = 0 // moveY = 0 // // console.log('鼠标按下', e) // clientXStart = e.screenX // clientYStart = e.screenY // }, // false // ) // ctx.canvas.addEventListener( // 'mouseup', // (e) => { // moveFlg = false // // console.log('鼠标抬起', e) // clientXEnd = e.screenX // clientYEnd = e.screenY // moveX = clientXEnd - clientXStart // moveY = clientYEnd - clientYStart // console.log( // '横向移动距离', // moveX, // '纵向移动距离', // moveY // // ctx.getTransform() // ) // if (moveX > 0) { // rotateSpeed = rotateSpeed * 2 // } else { // rotateSpeed = rotateSpeed / 2 // } // }, // false // )","link":"/about/js/index.js"},{"title":"","text":"gsap.registerPlugin(ScrollTrigger); let speed = 100; /* SCENE 1 */ let scene1 = gsap.timeline(); ScrollTrigger.create({ animation: scene1, trigger: \".scrollElement\", start: \"top top\", end: \"45% 100%\", scrub: 3, }); // hills animation scene1.to(\"#h1-1\", { y: 3 * speed, x: 1 * speed, scale: 0.9, ease: \"power1.in\" }, 0) scene1.to(\"#h1-2\", { y: 2.6 * speed, x: -0.6 * speed, ease: \"power1.in\" }, 0) scene1.to(\"#h1-3\", { y: 1.7 * speed, x: 1.2 * speed }, 0.03) scene1.to(\"#h1-4\", { y: 3 * speed, x: 1 * speed }, 0.03) scene1.to(\"#h1-5\", { y: 2 * speed, x: 1 * speed }, 0.03) scene1.to(\"#h1-6\", { y: 2.3 * speed, x: -2.5 * speed }, 0) scene1.to(\"#h1-7\", { y: 5 * speed, x: 1.6 * speed }, 0) scene1.to(\"#h1-8\", { y: 3.5 * speed, x: 0.2 * speed }, 0) scene1.to(\"#h1-9\", { y: 3.5 * speed, x: -0.2 * speed }, 0) //animate text scene1.to(\"#info\", { y: 8 * speed }, 0) /* Bird */ gsap.fromTo(\"#bird\", { opacity: 1 }, { y: -250, x: 800, ease: \"power2.out\", scrollTrigger: { trigger: \".scrollElement\", start: \"15% top\", end: \"60% 100%\", scrub: 4, onEnter: function() { gsap.to(\"#bird\", { scaleX: 1, rotation: 0 }) }, onLeave: function() { gsap.to(\"#bird\", { scaleX: -1, rotation: -15 }) }, } }) /* Clouds */ let clouds = gsap.timeline(); ScrollTrigger.create({ animation: clouds, trigger: \".scrollElement\", start: \"top top\", end: \"70% 100%\", scrub: 1, }); clouds.to(\"#cloud1\", { x: 500 }, 0) clouds.to(\"#cloud2\", { x: 1000 }, 0) clouds.to(\"#cloud3\", { x: -1000 }, 0) clouds.to(\"#cloud4\", { x: -700, y: 25 }, 0) /* Sun motion Animation */ let sun = gsap.timeline(); ScrollTrigger.create({ animation: sun, trigger: \".scrollElement\", start: \"top top\", end: \"2200 100%\", scrub: 1, }); //sun motion sun.to(\"#bg_grad\", { attr: { cy: \"330\" } }, 0.00) //bg change sun.to(\"#sun\", { attr: { offset: \"0.15\" } }, 0.00) sun.to(\"#bg_grad stop:nth-child(2)\", { attr: { offset: \"0.15\" } }, 0.00) sun.to(\"#bg_grad stop:nth-child(3)\", { attr: { offset: \"0.18\" } }, 0.00) sun.to(\"#bg_grad stop:nth-child(4)\", { attr: { offset: \"0.25\" } }, 0.00) sun.to(\"#bg_grad stop:nth-child(5)\", { attr: { offset: \"0.46\" } }, 0.00) sun.to(\"#bg_grad stop:nth-child(6)\", { attr: { \"stop-color\": \"#FF9171\" } }, 0) /* SCENE 2 */ let scene2 = gsap.timeline(); ScrollTrigger.create({ animation: scene2, trigger: \".scrollElement\", start: \"15% top\", end: \"40% 100%\", scrub: 4, }); scene2.fromTo(\"#h2-1\", { y: 500, opacity: 0 }, { y: 0, opacity: 1 }, 0) scene2.fromTo(\"#h2-2\", { y: 500 }, { y: 0 }, 0.1) scene2.fromTo(\"#h2-3\", { y: 700 }, { y: 0 }, 0.1) scene2.fromTo(\"#h2-4\", { y: 700 }, { y: 0 }, 0.2) scene2.fromTo(\"#h2-5\", { y: 800 }, { y: 0 }, 0.3) scene2.fromTo(\"#h2-6\", { y: 900 }, { y: 0 }, 0.3) /* Bats */ gsap.fromTo(\"#bats\", { opacity: 1, y: 400, scale: 0 }, { y: 120, scale: 0.8, transformOrigin: \"50% 50%\", ease: \"power3.out\", scrollTrigger: { trigger: \".scrollElement\", start: \"40% top\", end: \"70% 100%\", scrub: 3, onEnter: function() { gsap.utils.toArray(\"#bats path\").forEach((item, i) => { gsap.to(item, { scaleX: 0.5, yoyo: true, repeat: 11, duration: 0.15, delay: 0.7 + (i / 10), transformOrigin: \"50% 50%\" }) }); gsap.set(\"#bats\", { opacity: 1 }) }, onLeave: function() { gsap.to(\"#bats\", { opacity: 0, delay: 2 }) }, } }) /* Sun increase */ let sun2 = gsap.timeline(); ScrollTrigger.create({ animation: sun2, trigger: \".scrollElement\", start: \"2200 top\", end: \"5000 100%\", scrub: 1, }); sun2.to(\"#sun\", { attr: { offset: \"0.6\" } }, 0) sun2.to(\"#bg_grad stop:nth-child(2)\", { attr: { offset: \"0.7\" } }, 0) sun2.to(\"#sun\", { attr: { \"stop-color\": \"#ffff00\" } }, 0) sun2.to(\"#lg4 stop:nth-child(1)\", { attr: { \"stop-color\": \"#623951\" } }, 0) sun2.to(\"#lg4 stop:nth-child(2)\", { attr: { \"stop-color\": \"#261F36\" } }, 0) sun2.to(\"#bg_grad stop:nth-child(6)\", { attr: { \"stop-color\": \"#45224A\" } }, 0) /* Transition (from Scene2 to Scene3) */ gsap.set(\"#scene3\", { y: 580, visibility: \"visible\" }) let sceneTransition = gsap.timeline(); ScrollTrigger.create({ animation: sceneTransition, trigger: \".scrollElement\", start: \"70% top\", end: \"bottom 100%\", scrub: 3, }); sceneTransition.to(\"#h2-1\", { y: -680, scale: 1.5, transformOrigin: \"50% 50%\" }, 0) sceneTransition.to(\"#bg_grad\", { attr: { cy: \"-80\" } }, 0.00) sceneTransition.to(\"#bg2\", { y: 0 }, 0) /* Scene 3 */ let scene3 = gsap.timeline(); ScrollTrigger.create({ animation: scene3, trigger: \".scrollElement\", start: \"80% 50%\", end: \"bottom 100%\", scrub: 3, }); //Hills motion scene3.fromTo(\"#h3-1\", { y: 300 }, { y: -550 }, 0) scene3.fromTo(\"#h3-2\", { y: 800 }, { y: -550 }, 0.03) scene3.fromTo(\"#h3-3\", { y: 600 }, { y: -550 }, 0.06) scene3.fromTo(\"#h3-4\", { y: 800 }, { y: -550 }, 0.09) scene3.fromTo(\"#h3-5\", { y: 1000 }, { y: -550 }, 0.12) //stars scene3.fromTo(\"#stars\", { opacity: 0 }, { opacity: 0.5, y: -500 }, 0) // Scroll Back text scene3.fromTo(\"#arrow2\", { opacity: 0 }, { opacity: 0.7, y: -710 }, 0.25) scene3.fromTo(\"#text2\", { opacity: 0 }, { opacity: 0.7, y: -710 }, 0.3) //gradient value change scene3.to(\"#bg2-grad\", { attr: { cy: 600 } }, 0) scene3.to(\"#bg2-grad\", { attr: { r: 500 } }, 0) /* falling star */ gsap.to(\"#fstar\", { x: -700, y: -250, ease: \"power4.out\", scrollTrigger: { trigger: \".scrollElement\", start: \"4000 top\", end: \"6000 100%\", scrub: 5, onEnter: function() { gsap.set(\"#fstar\", { opacity: 1 }) }, onLeave: function() { gsap.set(\"#fstar\", { opacity: 0 }) }, } }) //reset scrollbar position after refresh window.onbeforeunload = function() { window.scrollTo(0, 0); } let fullscreen; let fsEnter = document.getElementById('fullscr'); fsEnter.addEventListener('click', function (e) { e.preventDefault(); if (!fullscreen) { fullscreen = true; document.documentElement.requestFullscreen(); fsEnter.innerHTML = \"退出全屏\"; } else { fullscreen = false; document.exitFullscreen(); fsEnter.innerHTML = \"全屏\"; } });","link":"/about/js/animate.js"}]}